
import qutip as qt
import numpy as np

class OperatorCollections():

    def __init__(self,dims=2):
        self.dims=int(dims)

    @property
    def I(self):
        return qt.qeye(self.dims)

    @property
    def destroy(self):
        return qt.destroy(self.dims)

    @property
    def create(self):
        return qt.destroy(self.dims).dag()

    @property
    def a(self):
        return self.destroy

    @property
    def x(self):
        return self.destroy+self.create

    @property
    def y(self):
        return -1j*(self.destroy-self.create)

    @property
    def p(self):
        return self.destroy(2)

    @property
    def m(self):
        return self.destroy(2).dag()

    @property
    def aa(self):
        return self.create*self.destroy

    @property
    def aaaa(self):
        return self.create*self.create*self.destroy*self.destroy

def Qflatten(Q):
    return qt.Qobj(Q.full())

def T(A, U):
    A = qt.Qobj(A)
    U = qt.Qobj(U)
    return U * A * U.dag()

def U(H,t):
    # unitary propagator generated by H over time t 
    H = qt.Qobj(H)
    return qt.Qobj(-1j * H * t).expm()

def str2oper(string='I,I,x',nTrunc=[3,3,3]):
    if isinstance(nTrunc,int):
        uniform_OP=OperatorCollections(nTrunc)
    i=0
    for oper_name in string.split(','):
        OP = uniform_OP if isinstance(nTrunc,int) else OperatorCollections(nTrunc[i])

        if i == 0:
            operator = getattr(OP,oper_name)
        else:
            operator=qt.tensor(operator,getattr(OP,oper_name))
        i+=1
    return Qflatten(operator)


dict_psi = {'+X':np.array([1,1]),
            '-X':np.array([1,-1]),
            '+Y':np.array([1,1j]),
            '-Y':np.array([1,-1j]),
            '+Z':np.array([1,0]),
            '-Z':np.array([0,1]),
            }

def str2state(string='+X+Y-Z',nTrunc=[3,3,3]):
    qubit_num  = int(len(string)/2)
    for i in range(qubit_num):
        state_label = string[i*2:i*2+2]
        Trunc = nTrunc if isinstance(nTrunc,int) else int(nTrunc[i])
        if i == 0:
            initial_state = qt.Qobj(np.append(dict_psi[state_label],np.zeros(Trunc-2))).unit()
        else:
            initial_state =  qt.tensor( initial_state,qt.Qobj(np.append(dict_psi[state_label],np.zeros(Trunc-2))).unit())
    return Qflatten(initial_state)

dict_Pauli = {'I':qt.qeye(2),
              'X':qt.sigmax(),
              'Y':qt.sigmay(),
              'Z':qt.sigmaz()}

def get_Pauli(pauli_label):
    for i,key in enumerate(pauli_label):
        if i == 0:
            pauli_oper = dict_Pauli[key]
        else:
            pauli_oper = qt.tensor( pauli_oper, dict_Pauli[key])
    return Qflatten(pauli_oper)

#################################  rb states #########################
RB_One_4 = np.array([[1,0j,0j,0j],[0j,1,0,0],[0j,0,1,0],[0j,0,0,1]])

RB_TWO_24 = np.array([[1, 1, 0, 0],
 [1, 0, 1, 0],
 [1, 0, 0, 1],
 [0, 1, 1, 0],
 [0, 1, 0, 1],
 [0, 0, 1, 1],
 [1, -1, 0, 0],
 [1, 0, -1, 0],
 [1, 0, 0, -1],
 [0, 1, -1, 0],
 [0, 1, 0, -1],
 [0, 0, 1, -1],
 [1, 1j, 0, 0],
 [1, 0, 1j, 0],
 [1, 0, 0, 1j],
 [0, 1, 1j, 0],
 [0, 1, 0, 1j],
 [0, 0, 1, 1j],
 [1, (-0-1j), 0, 0],
 [1, 0, (-0-1j), 0],
 [1, 0, 0, (-0-1j)],
 [0, 1, (-0-1j), 0],
 [0, 1, 0, (-0-1j)],
 [0, 0, 1, (-0-1j)]])/np.sqrt(2)

RB_Four_32=np.array([[(0.5+0j), 0.5j, (0.5+0j), 0.5j],
[(0.5+0j), 0.5j, -0.5j, (0.5+0j)],
[(0.5+0j), 0.5j, (-0.5+0j), (-0-0.5j)],
[(0.5+0j), 0.5j, (0.5+0j), (-0-0.5j)],
[(0.5+0j), 0.5j, 0.5j, (0.5+0j)],
[(0.5+0j), 0.5j, (-0.5+0j), 0.5j],
[(0.5+0j), 0.5j, 0.5j, (-0.5+0j)],
[(0.5+0j), 0.5j, (-0-0.5j), (-0.5+0j)],
[(0.5+0j), (-0-0.5j), (-0-0.5j), (-0.5+0j)],
[(0.5+0j), (-0-0.5j), (-0.5+0j), (-0-0.5j)],
[(0.5+0j), (-0-0.5j), 0.5j, (0.5+0j)],
[(0.5+0j), -0.5j, (0.5+0j), 0.5j],
[(0.5+0j), -0.5j, (0.5+0j), -0.5j],
[(0.5+0j), (-0-0.5j), (-0-0.5j), (0.5+0j)],
[(0.5+0j), -0.5j, (-0.5+0j), 0.5j],
[(0.5+0j), -0.5j, 0.5j, (-0.5+0j)],
[(0.5+0j), (0.5+0j), (0.5+0j), (-0.5+0j)],
[(0.5+0j), (0.5+0j), (-0.5+0j), (0.5+0j)],
[(0.5+0j), (0.5+0j), -0.5j, (-0-0.5j)],
[(0.5+0j), (0.5+0j), (0.5+0j), (0.5+0j)],
[(0.5+0j), (0.5+0j), (-0-0.5j), 0.5j],
[(0.5+0j), (0.5+0j), 0.5j, 0.5j],
[(0.5+0j), (0.5+0j), (-0.5+0j), (-0.5+0j)],
[(0.5+0j), (0.5+0j), 0.5j, -0.5j],
[(0.5+0j), (-0.5+0j), 0.5j, (-0-0.5j)],
[(0.5+0j), (-0.5+0j), 0.5j, 0.5j],
[(0.5+0j), (-0.5+0j), (-0.5+0j), (-0.5+0j)],
[(0.5+0j), (-0.5+0j), (0.5+0j), (-0.5+0j)],
[(0.5+0j), (-0.5+0j), (-0.5+0j), (0.5+0j)],
[(0.5+0j), (-0.5+0j), -0.5j, (-0-0.5j)],
[(0.5+0j), (-0.5+0j), (0.5+0j), (0.5+0j)],
[(0.5+0j), (-0.5+0j), -0.5j, 0.5j]])

RB_60 = np.append( np.append(RB_One_4,RB_TWO_24,axis=0),RB_Four_32,axis=0  )

def rb_idx2state(idx,nTrunc=[3,3,3]):
    dims = np.prod(nTrunc)
    init_state = np.zeros([dims])*1j
    subspace_state = RB_60[idx]
    init_state[0] = subspace_state[0]
    init_state[1] = subspace_state[1]

    init_state[ nTrunc[1]*nTrunc[2] ] = subspace_state[2]
    init_state[ nTrunc[1]*nTrunc[2]+1 ] = subspace_state[3] 
    return qt.Qobj(init_state)

def rb_idx2state_coupler_excited(idx,nTrunc=[3,3,3]):
    dims = np.prod(nTrunc)
    init_state = np.zeros([dims])*1j
    subspace_state = RB_60[idx]
    init_state[0+nTrunc[2]] = subspace_state[0]
    init_state[1+nTrunc[2]] = subspace_state[1]
    init_state[ nTrunc[1]*nTrunc[2] + nTrunc[2] ] = subspace_state[2]
    init_state[ nTrunc[1]*nTrunc[2] + nTrunc[2] + 1 ] = subspace_state[3] 
    return qt.Qobj(init_state)


################### quantum logic  gates ##################

class Gate():

    def __init__(self):
        self.Unitary_Oper = None

    @property
    def U(self):
        return Qflatten(self.Unitary_Oper)

class SingleQubitGate(Gate):

    def __init__(self,rot_axis_theta,rot_axis_phi,evolution_angle):

        rot_oper = np.cos(rot_axis_theta) * qt.sigmaz() + np.sin(rot_axis_theta) * np.cos(rot_axis_phi) * qt.sigmax() + np.sin(rot_axis_theta) * np.sin(rot_axis_phi) * qt.sigmay() 
        self.Unitary_Oper = np.cos(evolution_angle/2)* qt.qeye(2) - 1j * np.sin(evolution_angle/2) * rot_oper


class X_Gate(SingleQubitGate):

    def __init__(self,rot_angle):
        super().__init__( np.pi/2 , 0 , rot_angle)

class Y_Gate(SingleQubitGate):

    def __init__(self,rot_angle):
        super().__init__( np.pi/2 , np.pi/2 , rot_angle)

class Z_Gate(SingleQubitGate):

    def __init__(self,rot_angle):
        super().__init__( 0 , 0 , rot_angle)

